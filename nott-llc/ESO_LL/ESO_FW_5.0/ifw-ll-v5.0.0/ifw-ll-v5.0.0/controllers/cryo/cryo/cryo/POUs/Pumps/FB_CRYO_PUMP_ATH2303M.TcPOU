<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.12">
  <POU Name="FB_CRYO_PUMP_ATH2303M" Id="{b2abfb36-7795-48af-82bb-08716db152f5}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_CRYO_PUMP_ATH2303M EXTENDS FB_CRYO_PUMP_SERIAL
VAR_INPUT
END_VAR
VAR_OUTPUT
END_VAR
VAR
	{attribute 'OPC.UA.DA' := '1'}
	cfg:		T_CRYO_PUMP_ATM2303M_CFG;	
	{attribute 'OPC.UA.DA' := '1'}
	ctrl:		T_CRYO_PUMP_BASE_CTRL;	
	{attribute 'OPC.UA.DA' := '1'}
	{attribute 'OPC.UA.DA.Access' := '1'}
	stat:		T_CRYO_PUMP_ATM2303M_STAT;	


	// Input signals
	i_bReady		AT %I*:	BOOL;	// OK for Process, i.e. speed ≥ nominal speed
	i_bSpeed100		AT %I*:	BOOL;	// pump speed > 100 rpm
	i_bWarning		AT %I*:	BOOL;	// presence of a warning
	i_bAlarm		AT %I*:	BOOL;	// presence of an alarm

END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[
// Execute the base class object FB_CRYO_PUMP_SERIAL
SUPER^();

]]></ST>
    </Implementation>
    <Method Name="M_Configure" Id="{552e3818-8c60-4480-8472-0f471a98fc4f}">
      <Declaration><![CDATA[METHOD M_Configure
VAR_INPUT
END_VAR
VAR
	//
	// List of INIT commands.
	//
	cmdList_Init_ATH2303M:	ARRAY [1..8] OF T_CRYO_PUMP_CMD := [
		(cmd := cfg.C_CMD_IDN, 	length := 0),	// 29?
		(cmd := cfg.C_CMD_RDI, 	length := 0),	// 11?
		(cmd := cfg.C_CMD_VER, 	length := 92),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0)];

	//
	//	List of READ (and WRITE) commands.
	// NOTE: Monitoring loop stops on first cmd = ''.
	//
	cmdList_Read_ATH2303M:	ARRAY [1..16] OF T_CRYO_PUMP_CMD := [
		(cmd := cfg.C_CMD_SEL, 	length := 15),
		(cmd := cfg.C_CMD_STA, 	length := 78),
		(cmd := cfg.C_CMD_LEV, 	length := 66),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0),
		(cmd := '', 		length := 0)];
	
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[IF NOT bStarted	THEN
	//
	// START: Mandatory for ALL pumps !!!
	//
	// Set references from FB_RS_BASE
	cfgRef	REF=cfg;
	ctrlRef	REF=ctrl;
	statRef	REF=stat;

	// Set references from FB_CRYO_TMP_BASE
	cfgBaseRef	REF=cfg;
	ctrlBaseRef	REF=ctrl;
	statBaseRef	REF=stat;

	// Copy input parameters to configuration
	cfg.nModel			:= in_nModel;
	cfg.bAutoMonitor	:= in_bAutoMonitor;
	cfg.tDelay_Periodic	:= DINT_TO_TIME(in_nPeriod);
	
	
	// Set pointers to arrays of commands
	ptrInitCmds	:= ADR(cfg.cmdList_Init);(* Pointer to INIT commands *)
	ptrReadCmds	:= ADR(cfg.cmdList_Read);(* Pointer to READ commands *)
	
	// TODO in FB that extends the functionality
	// Set pointers to comm, i.e.
	ptrCommCfg	:= ADR(comm.cfg);	(* Pointer to comm.cfg instance *)
	ptrCommCtrl	:= ADR(comm.ctrl);	(* Pointer to comm.ctrl instance *)
	ptrCommStat	:= ADR(comm.stat);	(* Pointer to comm.stat instance *)
	
	// Set comm suffixes for commands and replies
	ptrCommCfg^.sCmdSuffix		:= in_sCmdSuffix;
	ptrCommCfg^.sReplySuffix	:= in_sReplySuffix;

	statRef.bConfigured	:= TRUE;
	bStarted			:= TRUE;
	//
	// END: Mandatory for ALL pumps !!!
	//


	//
	// ATH specific configuration
	//
	
	// Assign INIT and READ commands.
	cfg.cmdList_Init	:= cmdList_Init_ATH2303M;
	cfg.cmdList_Read	:= cmdList_Read_ATH2303M;
END_IF


]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetSpeed" Id="{c4cd5ee2-5f58-4f2f-a855-e7a0b17036c0}">
      <Declaration><![CDATA[METHOD M_GetSpeed : DINT
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetSpeed	:= stat.nPumpSpeed;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsReady" Id="{34db9e89-5aec-41f8-96c5-78f3464ccde8}">
      <Declaration><![CDATA[METHOD M_IsReady : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_IsReady	:= stat.bReady;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_IsRunning" Id="{a9402123-8267-42f2-95f1-fd26cee80886}">
      <Declaration><![CDATA[METHOD M_IsRunning : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_IsRunning	:= stat.bMoving;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ReadFromReply" Id="{4621c515-eb85-4899-9196-d1604ea997e4}">
      <Declaration><![CDATA[METHOD M_ReadFromReply : BOOL
// Method to check correctness of the reply and assign the result to a status variable.
VAR_INPUT
	idx:		INT;		(* arr [idx] will hold the first extracted value, arr [idx+1] the second one, etc. *)
	bInitCmd:	BOOL := FALSE;
END_VAR
VAR
	pos:	INT;
	cmd:	STRING;
	length:	DINT;
	subStr:	STRING(255);
END_VAR]]></Declaration>
      <Implementation>
        <ST><![CDATA[// During INIT it might happen that the command index is 0.
// These cases should be discarded.
IF idx <= 0	THEN
	M_ReadFromReply	:= TRUE;
	RETURN;
END_IF

IF bInitCmd	THEN
	cmd		:= cfg.cmdList_Init[idx].cmd;
	length	:= cfg.cmdList_Init[idx].length;
ELSE
	cmd		:= cfg.cmdList_Read[idx].cmd;
	length	:= cfg.cmdList_Read[idx].length;
END_IF

IF length <> 0  AND  LEN(stat.sReply) <> length THEN
	M_ReadFromReply	:= FALSE;
	RETURN;
END_IF

IF cmd = cfg.C_CMD_STA	THEN
	stat.nPumpSpeed		:= STRING_TO_DINT(MID(stat.sReply,5,10));
	stat.nMotorVolt		:= STRING_TO_DINT(MID(stat.sReply,2,36));
	stat.nMotorCurr		:= STRING_TO_DINT(MID(stat.sReply,5,39));
	stat.nPumpTemp		:= STRING_TO_DINT(MID(stat.sReply,3,45));
	stat.nElecTemp	:= STRING_TO_DINT(MID(stat.sReply,3,49));
ELSIF cmd = cfg.C_CMD_LEV	THEN
	stat.nNominalSpeed				:= STRING_TO_DINT(MID(stat.sReply,5,6));
	stat.nStandbySpeed				:= STRING_TO_DINT(MID(stat.sReply,5,12));
	stat.nPumpHours					:= STRING_TO_DINT(MID(stat.sReply,5,26));
	stat.nElecHours					:= STRING_TO_DINT(MID(stat.sReply,5,32));
	stat.nSetPoint_AtSpeed			:= STRING_TO_DINT(MID(stat.sReply,2,54));
	stat.nSetPoint_Temp				:= STRING_TO_DINT(MID(stat.sReply,2,57));
	stat.nSetPoint_BearingWarn		:= STRING_TO_DINT(MID(stat.sReply,2,60));
	stat.nSetPoint_BearingCounter	:= STRING_TO_DINT(MID(stat.sReply,3,63));
ELSIF cmd = cfg.C_CMD_IDN	THEN
	stat.sIDN	:= MID(stat.sReply, LEN(stat.sReply)-6, 6);	// Strip the string off prefix and sufix.
ELSIF cmd = cfg.C_CMD_RDI	THEN
	stat.sRDI	:= MID(stat.sReply, LEN(stat.sReply)-6, 6);	// Strip the string off prefix and sufix.
ELSIF cmd = cfg.C_CMD_VER	THEN
	subStr		:= MID(stat.sReply, LEN(stat.sReply)-6, 6);	// Strip the string off prefix and sufix.
	pos			:= FIND(subStr, ',');	// Find first comma
	stat.sVer1	:= MID(subStr, pos-1, 1);	// Assign substring up to the first comma char
	subStr		:= MID(subStr, LEN(subStr)-pos, pos+1);	// Take the string after sVer1 and comma.
	pos			:= FIND(subStr, ',');	// Find next comma
	stat.sVer2	:= MID(subStr, pos-1, 1);	// Take the string up to the comma
	subStr		:= MID(subStr, LEN(subStr)-pos, pos+1);	// Take the string after sVer1 and comma.
	pos			:= FIND(subStr, ',');	// Find next comma
	stat.sVer3	:= MID(subStr, pos-1, 1);	// Take the string up to the comma
	subStr		:= MID(subStr, LEN(subStr)-pos, pos+1);	// Take the string after sVer1 and comma.
	stat.sVer4	:= subStr;	// Take the rest as sVer4
ELSIF cmd = cfg.C_CMD_SEL	THEN
	stat.nCtrlMode		:= STRING_TO_DINT(MID(stat.sReply,1,14));
END_IF


M_ReadFromReply	:= true;	// OK]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_UpdateStatus" Id="{28f6f6ea-2c30-44b3-a5d6-78f4a0959536}">
      <Declaration><![CDATA[METHOD M_UpdateStatus
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// Update Status from digital inputs readings
stat.bReady		:= i_bReady;
stat.bSpeed100	:= i_bSpeed100;
stat.bWarning	:= NOT i_bWarning;	// Active low
stat.bAlarm		:= NOT i_bAlarm;	// Active low

stat.bMoving	:= stat.bReady OR stat.bSpeed100 OR stat.nPumpSpeed > 0;

// Set Control Mode Label
CASE stat.nCtrlMode	OF
	0:	stat.sCtrlMode	:= 'HHR (Hand-Held Remote)';
	1:	stat.sCtrlMode	:= 'REMOTE';
	2:	stat.sCtrlMode	:= 'SERIAL LINK';
	3:	stat.sCtrlMode	:= 'FIELDBUS';
ELSE
	stat.sCtrlMode	:= 'UNKNOWN';
END_CASE

]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M">
      <LineId Id="78" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="43" Count="0" />
      <LineId Id="9" Count="0" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M.M_Configure">
      <LineId Id="77" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="158" Count="1" />
      <LineId Id="100" Count="3" />
      <LineId Id="98" Count="0" />
      <LineId Id="157" Count="0" />
      <LineId Id="104" Count="2" />
      <LineId Id="163" Count="15" />
      <LineId Id="184" Count="0" />
      <LineId Id="226" Count="3" />
      <LineId Id="185" Count="1" />
      <LineId Id="160" Count="2" />
      <LineId Id="107" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="180" Count="2" />
      <LineId Id="152" Count="0" />
      <LineId Id="96" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="80" Count="0" />
      <LineId Id="75" Count="1" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M.M_GetSpeed">
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M.M_IsReady">
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M.M_IsRunning">
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M.M_ReadFromReply">
      <LineId Id="97" Count="1" />
      <LineId Id="91" Count="0" />
      <LineId Id="95" Count="1" />
      <LineId Id="94" Count="0" />
      <LineId Id="92" Count="0" />
      <LineId Id="55" Count="1" />
      <LineId Id="81" Count="0" />
      <LineId Id="59" Count="0" />
      <LineId Id="58" Count="0" />
      <LineId Id="82" Count="0" />
      <LineId Id="57" Count="0" />
      <LineId Id="83" Count="4" />
      <LineId Id="7" Count="0" />
      <LineId Id="2" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="78" Count="1" />
      <LineId Id="62" Count="1" />
      <LineId Id="118" Count="2" />
      <LineId Id="125" Count="1" />
      <LineId Id="121" Count="3" />
      <LineId Id="99" Count="2" />
      <LineId Id="141" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="129" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="130" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="133" Count="0" />
      <LineId Id="132" Count="0" />
      <LineId Id="135" Count="3" />
      <LineId Id="140" Count="0" />
      <LineId Id="127" Count="1" />
      <LineId Id="61" Count="0" />
      <LineId Id="69" Count="1" />
      <LineId Id="68" Count="0" />
    </LineIds>
    <LineIds Name="FB_CRYO_PUMP_ATH2303M.M_UpdateStatus">
      <LineId Id="105" Count="0" />
      <LineId Id="76" Count="0" />
      <LineId Id="89" Count="2" />
      <LineId Id="127" Count="0" />
      <LineId Id="126" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="93" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="97" Count="4" />
      <LineId Id="96" Count="0" />
      <LineId Id="122" Count="0" />
      <LineId Id="108" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>