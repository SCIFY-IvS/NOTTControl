<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.3">
  <POU Name="FB_RS_COMM_BASE" Id="{eadf5176-8954-4706-8294-586960c02a3b}" SpecialFunc="None">
    <Declaration><![CDATA[FUNCTION_BLOCK FB_RS_COMM_BASE
VAR_INPUT
	in_bSimulation:		BOOL := FALSE;
	in_nModel:			DINT;	// Device model number. Zero if N/A.
	in_sCmdSuffix:		STRING(16) := '$0D$0A';	// Terminator for command, default '<CR><LF>'
	in_sReplySuffix:	STRING(16) := '$0D$0A';	// Terminator for reply, default '<CR><LF>'
	in_nTimeout:		DINT := 3000;			// Timeout [ms] on command reply. Default 3000 (3 sec)
END_VAR
VAR_OUTPUT
END_VAR
VAR CONSTANT
END_VAR
VAR
	{attribute 'OPC.UA.DA' := '1'}
	cfgRef:			REFERENCE TO T_RS_COMM_CFG;		// Config parameters
	{attribute 'OPC.UA.DA' := '1'}
	ctrlRef:		REFERENCE TO T_RS_COMM_CTRL;	// Control parameters
	{attribute 'OPC.UA.DA' := '1'}
	{attribute 'OPC.UA.DA.Access' := '1'}
	infoRef:		REFERENCE TO T_RS_COMM_INFO; 	// Info parameters - ReadOnly
	{attribute 'OPC.UA.DA' := '1'}
	{attribute 'OPC.UA.DA.Access' := '1'}
	statRef:		REFERENCE TO T_RS_COMM_STAT;	// Status parameters - ReadOnly

	{attribute 'OPC.UA.DA' := '0'}
	simRef:			REFERENCE TO FB_SIM_RS_COMM_BASE;	// Reference to COMM simulator


	// Physical signals - to be mapped
	i_nCouplerState	AT %I*	: UINT;			(* Link it to Coupler->InfoData->State *)

	(* Serial line control *)
//	COMportControl: 		SerialLineControl;
	RxBuffer:				ComBuffer;		(* Receive data buffer; used with all receive function blocks *)
	TxBuffer:				ComBuffer;		(* Transmit data buffer; used with all receive function blocks *)

	(* Send/Receive FB's and VAR's *)
	Receive: 			ReceiveString255;
	Send:				SendString;
	ClearComBufferTx:	ClearComBuffer;
	ClearComBufferRx:	ClearComBuffer;
	ComReset:			ComReset;

	DeviceReply: 		STRING(255);

	(* Timers *)
	fbTimer:			TON; (* Timeout for RECEIVE *)

	State:				INT := E_RS_COMM_STATE.NOT_INIT;
	nextState:			INT := E_RS_COMM_STATE.IDLE;

	cmd:				STRING;

	nNumReplies:		DINT := 0;

	pos:				INT;
END_VAR
]]></Declaration>
    <Implementation>
      <ST><![CDATA[(* ============================================
	Check if the HW is OK. 
	The coupler state must be 8, i.e. OPERATIONAL (if not simulated).
============================================== *)
IF i_nCouplerState <> 8  AND  NOT in_bSimulation  THEN	(* If the hardware status is NOT OK, we cannot trust the readings. *)
	statRef.nErrorCode	:= E_RS_COMM_ERROR.NOT_IN_OP_STATE;
	statRef.sErrorText	:= 'Not in OPERATIONAL state. Check if variable i_nCouplerState is linked to HW.';
	statRef.nStatus		:= E_RS_COMM_STATUS.ERROR;
	statRef.sStatus		:= 'ERROR';
	RETURN;
END_IF

//
// Execute Simulator, if in simulation
//
IF in_bSimulation  THEN
	simRef(in_nModel := in_nModel, in_sReplySuffix := in_sReplySuffix);
END_IF

(*====================================================
	Handling of commands sent through OPC UA interface.
	Executed only when flag bExecute goes from LOW to HIGH.
	bExecute is reset by the PLC application.
=====================================================*)

IF ctrlRef.bExecute THEN
	ctrlRef.bExecute	:= FALSE;
	(* Save last command and reset the command *)
	statRef.nLastCommand 	:= ctrlRef.nCommand;
	ctrlRef.nCommand		:= E_RS_COMM_CMD.NONE;

	(* Commands can only be sent when device is IDLE *)
	IF statRef.nLastCommand <> E_RS_COMM_CMD.INIT  AND  State <> E_RS_COMM_STATE.IDLE THEN
		State 				:= E_RS_COMM_STATE.ERROR;
		statRef.nStatus		:= E_RS_COMM_STATUS.ERROR;
		statRef.sStatus		:= 'ERROR';
		statRef.nErrorCode	:= E_RS_COMM_ERROR.NOT_IDLE;
		statRef.sErrorText	:= 'Device busy. Should be in IDLE to receive commands.';
		RETURN;
	END_IF


	(* Device has to be initialised before being used *)
	IF statRef.nLastCommand <> E_RS_COMM_CMD.INIT THEN
		IF NOT statRef.bInitialised  THEN
			State 				:= E_RS_COMM_STATE.ERROR;
			statRef.nStatus		:= E_RS_COMM_STATUS.ERROR;
			statRef.sStatus		:= 'ERROR';
			statRef.nErrorCode	:= E_RS_COMM_ERROR.NOT_INIT;
			statRef.sErrorText	:= 'Device not initialised.';
			RETURN;
		END_IF
	END_IF



	CASE statRef.nLastCommand OF
	E_RS_COMM_CMD.INIT:
		// Comm port specific.
		// M_ActionInitExecute() has to set next State!!!
		M_ActionInitExecute();

	E_RS_COMM_CMD.SEND:
		statRef.nErrorCode	:= E_RS_COMM_ERROR.OK;
		statRef.nStatus		:= E_RS_COMM_STATUS.BUSY;
		statRef.sErrorText	:= 'OK';
		statRef.sStatus		:= 'BUSY';
		State 				:= E_RS_COMM_STATE.PREPARE_SEND;

	END_CASE

END_IF



(*====================================================
	Background communication with KL60xx terminal.
	Called only during Send or Receive!!!
	It communicates with the serial line hardware device and 
	transmits or receives data.
=====================================================*)

CASE State OF
E_RS_COMM_STATE.IDLE,
E_RS_COMM_STATE.CONNECT,
E_RS_COMM_STATE.CLEAR_BUFFER,
E_RS_COMM_STATE.SEND,
E_RS_COMM_STATE.RECEIVE:
	// Backgroung communication control.
	// This method is just a place holder..
	// TODO: Implement for each communication protocol, i.e. for RS and ADS/USB.
	M_ComPortControl();	

END_CASE





(*======================
=======================
 	State machine 
=======================
=======================*)

CASE State OF

E_RS_COMM_STATE.ERROR:
	ClearComBufferTx (Buffer := TxBuffer);
	ClearComBufferRx (Buffer := RxBuffer);
	statRef.nStatus	:= E_RS_COMM_STATUS.ERROR;
	statRef.sStatus	:= 'ERROR';
	State 			:= E_RS_COMM_STATE.IDLE;
	RETURN;


E_RS_COMM_STATE.NOT_INIT:
	ClearComBufferTx (Buffer := TxBuffer);
	ClearComBufferRx (Buffer := RxBuffer);
	statRef.bInitialised	:= FALSE;
	statRef.nErrorCode		:= E_RS_COMM_ERROR.OK;
	statRef.sErrorText		:= 'OK';
	statRef.nStatus			:= E_RS_COMM_STATUS.NOT_INIT;
	statRef.sStatus			:= 'NOT INIT';


E_RS_COMM_STATE.IDLE:
	(* Nothing to do in IDLE *)
	RETURN;


E_RS_COMM_STATE.CONNECT:
	M_ActivityConnect();

	
E_RS_COMM_STATE.RESET:
	// Specific call of communication reset
	M_Reset();
	RETURN;


E_RS_COMM_STATE.PREPARE_SEND:
	(*******************************************************************************************
	Here we set the command string, i.e. add suffix if not included in the command.
	Then, the state is changed to  E_RS_COMM_STATE.SEND.
	********************************************************************************************)

	(* Clear reply string *)
	DeviceReply	:= '';

	cmd	:= ctrlRef.sCmd;

	statRef.nStatus	:= E_RS_COMM_STATUS.BUSY;
	statRef.sStatus	:= 'BUSY';

	(* Add suffix CR/LF to the user command if missing *)
	pos := FIND(cmd,cfgRef.sCmdSuffix);
	IF pos = 0 THEN
		cmd := CONCAT(cmd, cfgRef.sCmdSuffix);
	END_IF

	//
	// If in simulation, there is no need to send anything.
	// Just get a reply from the simulator and go to IDLE state.
	//
	IF in_bSimulation THEN
		fbTimer (IN := FALSE); 	(* reset timer *)
		ClearComBufferRx (Buffer := RxBuffer);
		statRef.sReply	:= simRef.M_GetSimReply(cmd);	// Get simulated reply
		State 			:= E_RS_COMM_STATE.IDLE;
		statRef.nStatus	:= E_RS_COMM_STATUS.IDLE;
		statRef.sStatus	:= 'IDLE';
	ELSE	
		ClearComBufferTx (Buffer := TxBuffer);
		statRef.nStatus	:= E_RS_COMM_STATUS.BUSY;
		statRef.sStatus	:= 'BUSY';
		nNumReplies		:= 0;		(* Have not received any reply yet. Used for handling multiple replies. *)
		State 			:= E_RS_COMM_STATE.SEND;
	END_IF
	RETURN;


E_RS_COMM_STATE.SEND:
	(* Send the command via serial port. *)
	Send(
		SendString	:= cmd,
		TXbuffer	:= TxBuffer);

	(* If the string was not sent in one cycle, go to next cycle *)
	IF Send.Busy THEN
		RETURN;
	ELSE
		IF Send.Error <> ComError_t.COMERROR_NOERROR THEN
			State 			:= E_RS_COMM_STATE.ERROR;
			statRef.nErrorCode	:= E_RS_COMM_ERROR.SEND;
			statRef.sErrorText	:= 'Send Failed';
		ELSE
			fbTimer (IN := FALSE);	// reset timer
		
			statRef.sReply := ''; 				(* No reply yet *)
		
			(* 	The command has been sent.
				If there is no reply, goto IDLE state.
				Otherwise, goto RECEIVE state. *)
			IF ctrlRef.bHasReply THEN
				State := E_RS_COMM_STATE.RECEIVE; 	(* Next state is RECEIVE *)
			ELSE
				(* Prepare next state *)
				State 			:= E_RS_COMM_STATE.IDLE;	 	(* Next state is IDLE *)
				statRef.nStatus	:= E_RS_COMM_STATUS.IDLE;
				statRef.sStatus	:= 'IDLE';
			END_IF
			RETURN;
		END_IF
	END_IF


E_RS_COMM_STATE.RECEIVE:
	(* Start the timeout timer for receive *)
	fbTimer (IN := TRUE, PT := DINT_TO_TIME(cfgRef.nTimeout+500)); (* 500ms extra timeout for reply *)


	(* Check for timeout. Goto ERROR if timeout expired. *)
	IF fbTimer.Q THEN
		fbTimer (IN := FALSE); (* reset timer *)

		State 			:= E_RS_COMM_STATE.ERROR;
		statRef.nErrorCode	:= E_RS_COMM_ERROR.TIMEOUT;
		statRef.sErrorText	:= 'Timeout on Receive';
		RETURN;
	END_IF

	(* Wait for the reply *)
	Receive(
		Prefix			:= '',
		Suffix			:= cfgRef.sReplySuffix,
		Timeout			:= DINT_TO_TIME(cfgRef.nTimeout),
		ReceivedString	:= DeviceReply,
		RXbuffer		:= RxBuffer,
		Reset			:= FALSE);


	(* Check for possible errors *)
	IF Receive.Error <> ComError_t.COMERROR_NOERROR OR  Receive.RxTimeout THEN
		fbTimer (IN := FALSE);	(* reset timer *)

		State 	:= E_RS_COMM_STATE.ERROR;
		statRef.nErrorCode	:= E_RS_COMM_ERROR.RECEIVE;
		statRef.sErrorText	:= 'Receive Failed';
		RETURN;
	END_IF

	(* Handle reply *)
	IF Receive.StringReceived THEN
		(* We have received a reply. Reset timers and triggers. *)
		fbTimer (IN := FALSE); 	(* reset timer *)

		statRef.sReply := CONCAT(statRef.sReply, DeviceReply);	(* CONCAT the reply *)
		nNumReplies	:= nNumReplies + 1;	(* Increment the number of replies *)

		IF nNumReplies = ctrlRef.nNumReplies THEN
			(* Clear the receive buffer ONLY when all replies have been received! *)
			ClearComBufferRx (Buffer := RxBuffer);
			State 			:= E_RS_COMM_STATE.IDLE;
			statRef.nStatus	:= E_RS_COMM_STATUS.IDLE;
			statRef.sStatus	:= 'IDLE';
		ELSE
			(* Stay in the same state and receive further replies *)
			;
		END_IF

		RETURN;

	END_IF



E_RS_COMM_STATE.CLEAR_BUFFER:
	(* Read any character present in the receive buffer *)
	(* 1 sec timeout for reply *)
	fbTimer (IN := TRUE, PT := T#1S);
	IF fbTimer.Q THEN
		(* reset timer *)
		fbTimer (IN := FALSE);
		statRef.bInitialised	:= TRUE;
		statRef.nStatus			:= E_RS_COMM_STATUS.IDLE;
		statRef.sStatus			:= 'INITIALISED';
		State 					:= E_RS_COMM_STATE.IDLE;
		RETURN;
	END_IF

	Receive(
		Prefix			:= '',
		Suffix			:= '',
		Timeout			:= T#500MS,
		ReceivedString	:= DeviceReply,
		RXbuffer		:= RxBuffer,
		Reset			:= FALSE);


ELSE
(* Unsuported state *)
	State 			:= E_RS_COMM_STATE.ERROR;
	statRef.nErrorCode	:= E_RS_COMM_ERROR.WRONG_STATE;
	statRef.sErrorText	:= 'Unknown State';
END_CASE



]]></ST>
    </Implementation>
    <Method Name="M_ActionInitExecute" Id="{0217622c-4a43-44ad-9b67-5c196d59a630}">
      <Declaration><![CDATA[METHOD M_ActionInitExecute
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: Implement in extended FB]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ActivityConnect" Id="{57a33526-2a33-45fc-bbb2-94eb0bf40117}">
      <Declaration><![CDATA[METHOD M_ActivityConnect
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: Implement in extended FB
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_ComPortControl" Id="{c4cfb64b-a497-4cbd-8d54-64fc75fc6cf8}">
      <Declaration><![CDATA[METHOD M_ComPortControl
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: Implement in extended FB
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetInitialised" Id="{da2cd91a-f237-4219-82ce-03e586002126}">
      <Declaration><![CDATA[METHOD M_GetInitialised : BOOL
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetInitialised	:= statRef.bInitialised;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_GetStatus" Id="{4927dbb2-9904-486b-8637-a6b398bf87bf}">
      <Declaration><![CDATA[METHOD M_GetStatus : E_RS_COMM_STATUS
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[M_GetStatus	:= statRef.nStatus;
]]></ST>
      </Implementation>
    </Method>
    <Method Name="M_Reset" Id="{9636b598-6bcf-4ab7-871d-a58588af0753}">
      <Declaration><![CDATA[METHOD M_Reset
VAR_INPUT
END_VAR
]]></Declaration>
      <Implementation>
        <ST><![CDATA[// TODO: Implement in extended FB
]]></ST>
      </Implementation>
    </Method>
    <LineIds Name="FB_RS_COMM_BASE">
      <LineId Id="1730" Count="10" />
      <LineId Id="2044" Count="0" />
      <LineId Id="2043" Count="0" />
      <LineId Id="1741" Count="0" />
      <LineId Id="2045" Count="0" />
      <LineId Id="1742" Count="0" />
      <LineId Id="2041" Count="1" />
      <LineId Id="1743" Count="141" />
      <LineId Id="2027" Count="5" />
      <LineId Id="2034" Count="0" />
      <LineId Id="2040" Count="0" />
      <LineId Id="2039" Count="0" />
      <LineId Id="2036" Count="2" />
      <LineId Id="2033" Count="0" />
      <LineId Id="1886" Count="135" />
      <LineId Id="2" Count="0" />
    </LineIds>
    <LineIds Name="FB_RS_COMM_BASE.M_ActionInitExecute">
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RS_COMM_BASE.M_ActivityConnect">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RS_COMM_BASE.M_ComPortControl">
      <LineId Id="24" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
    <LineIds Name="FB_RS_COMM_BASE.M_GetInitialised">
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_RS_COMM_BASE.M_GetStatus">
      <LineId Id="5" Count="1" />
    </LineIds>
    <LineIds Name="FB_RS_COMM_BASE.M_Reset">
      <LineId Id="6" Count="0" />
      <LineId Id="5" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>